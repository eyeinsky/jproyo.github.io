<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>From Lambda Calculus to Functional Programming | by Juan Pablo Royo @juanpabloroyo</title>
    <meta name="description" content="From Lambda Calculus to Functional Programming Slides" />
    <meta name="author" content="Juan Pablo Royo Sales" />
    <link rel="stylesheet" href="/css/font-faces.css">
    <link rel="stylesheet" href="/css/extras/hybrid.css">

    <!--
        Styles specific for this example presentation.
    -->
    <link href="/css/slides/markdown-slides.css" rel="stylesheet" />
    <link href="/css/extras/devopsy.css" rel="stylesheet" />
    <link href="/css/extras/effects.css" rel="stylesheet" />
</head>

<body class="impress-not-supported">
<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress" data-transition-duration="0">

<div class="step slide" data-rel-x="1800" data-rel-y="0">

<h1>From Lambda Calculus to Functional Programming</h1>
<div style="display: block;">
    <img src="/assets/images/super-lambda.jpg" style="float: left"/>
    <img src="/assets/images/haskell.svg" style="width: 15%"/>
    <img src="http://ocaml.org/logo/Colour/PNG/colour-logo.png"
         alt="OCaml"
         style="border: none; width: 150px;" />
    <img src="/assets/images/idris.png" style="width: 15%"/>
    <img src="/assets/images/clojure.svg" style="width: 15%"/>
    <img src="/assets/images/scala.svg" style="width: 15%"/>
</div>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h2>
        <p>
            When a Mathematical Reasoning can be had
            it’s as great a folly to make use of any other, as
            to grope for a thing in the dark, when you have
            a Candle standing by you.
        </p>
        <p><i>John Arbuthnot</i><br/>
            <i>Of the Laws of Chance, 1692</i></p>
    </h2>
</div>


<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Agenda</h1>
    <ul>
        <li>A brief of History</li>
        <li>Functional Programming</li>
        <li>Data structures: Datatypes, Types, Typeclasses and more</li>
        <li>Type Level Programming</li>
        <li>Theorems for free</li>
    </ul>

</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Agenda</h1>
    <ul>
        <li><strong>A brief of History</strong></li>
        <li>Functional Programming</li>
        <li>Data structures: Datatypes, Types, Typeclasses and more</li>
        <li>Type Level Programming</li>
        <li>Theorems for free</li>
    </ul>

</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Computability Theory</h1>
    <blockquote>
        <p>
            Branch of mathematics <b>(logic)</b> - Study of <b>Computable Functions</b> / Solvable Problems. (Before 1930 - No machines)
            $ f(x) = y $
        </p>
    </blockquote>
</div>

<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">

# Computability Theory

> ![Hilbert](/assets/images/Hilbert.jpg) David Hilbert (1862 – 1943) belived all problems were solvable, but around 1930  Gödel, Turing, and Church showed that this is not the case.
</div>

<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Computability Theory

![Alonzo Church](/assets/images/Alonzo_Church.jpg) Alonzo Church (1903 – 1995) Discovered/Introduced in 1930 **Lambda Calculus** as a formal system for expressing computations based on function abstractions and function applications.

</div>
<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Lambda Calculus (a.k.a. Untyped Lambda Calculus)

## Lambda Terms - Only 3 elements
## $ Set \Lambda of all \lambda-terms $

</div>
<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Lambda Calculus (a.k.a. Untyped Lambda Calculus)

## Lambda Terms - Only 3 elements
## $ Set \Lambda of all \lambda-terms $

* $ (Variable) \mapsto u \in V \implies u \in \Lambda$

</div>
<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Lambda Calculus (a.k.a. Untyped Lambda Calculus)

## Lambda Terms - Only 3 elements
## $ Set \Lambda of all \lambda-terms $

* $ (Variable) \mapsto u \in V \implies u \in \Lambda$
* $ (Application) \mapsto M \land N \in \Lambda \implies (MN) \in \Lambda$

</div>
<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Lambda Calculus (a.k.a. Untyped Lambda Calculus)

## Lambda Terms - Only 3 elements
## $ Set \Lambda of all \lambda-terms $

* $ (Variable) \mapsto u \in V \implies u \in \Lambda $
* $ (Application) \mapsto M \land N \in \Lambda \implies (MN) \in \Lambda $
* $ (Abstraction) \mapsto u \in V \land M \in \Lambda \implies \(\lambda u.M\) \in \Lambda $
</div>
<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# $\(\lambda u.M\)$ Examples

* Booleans = True | False
* $ \lambda xy.x \cong TRUE$
* $ \lambda xy.y \cong FALSE$

</div>
<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# $\(\lambda u.M\)$ Examples

* Booleans = True | False
* $ \lambda xy.x \cong TRUE$
* $ \lambda xy.y \cong FALSE$
* Natural Numbers
* $ 0 \cong \lambda fx.x$
* $ 1 \cong \lambda fx.fx$
* $ 2 \cong \lambda fx.f\(fx\)$
* $ 3 \cong \lambda fx.f\(f\(fx\)\)$
* and so on.....
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Agenda</h1>
    <ul>
        <li>A brief of History</li>
        <li><strong>Functional Programming</strong></li>
        <li>Data structures: Datatypes, Types, Typeclasses and more</li>
        <li>Type Level Programming</li>
        <li>Theorems for free</li>
    </ul>

</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Functional Programming</h1>
    <ul>
        <li>Functional programming is a style of programming which models computations as the evaluation of expressions</li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Functional Programming</h1>
    <ul>
        <li>Functional programming is a style of programming which models computations as the evaluation of expressions</li>
        <li>Programs are executed by evaluating expressions. In <strong>Imperative programming</strong> program are composed of statements which change global state when executed.</li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Functional Programming</h1>
    <ul>
        <li>Functional programming is a style of programming which models computations as the evaluation of expressions</li>
        <li>Programs are executed by evaluating expressions. In <strong>Imperative programming</strong> program are composed of statements which change global state when executed.</li>
        <li>Functions are <b>First-class</b></li>
   </ul>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Functional Programming</h1>
    <ul>
        <li>Paradigm that relies on functions modeled on <b>mathematical functions $\cong \lambda Calculus?$</b></li>
        <li>Programs are executed by evaluating expressions. In <strong>Imperative programming</strong> program are composed of statements which change global state when executed.</li>
        <li>Functions are <b>First-class</b></li>
        <li>Pure functions
            <ul>
                <li>Referential transparency: <b>same function</b>, given the <b>same values</b> to be evaluated, will always return the <b>same result</b> $\cong Math$</li>
            </ul>
        </li>
    </ul>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Functional Programming</h1>
    <ul>
        <li>Paradigm that relies on functions modeled on <b>mathematical functions $\cong \lambda Calculus?$</b></li>
        <li>Programs are executed by evaluating expressions. In <strong>Imperative programming</strong> program are composed of statements which change global state when executed.</li>
        <li>Functions are <b>First-class</b></li>
        <li>Pure functions
            <ul>
                <li>Referential transparency: <b>same function</b>, given the <b>same values</b> to be evaluated, will always return the <b>same result</b> $\cong Math$</li>
            </ul>
        </li>
        <li>Why is RF so important?
            <ul>
                <li>Deterministic, Composable, Testable, No Side Effects Programs</li>
            </ul>
        </li>
    </ul>
</div>

<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Functional Programming
> Well defined FP languages like Haskell, Scala, Agda, etc also are **Lazy** and Strict Typed Language.
> Combination of all these properties build well formal defined language tooling

$ \lambda Calculus \land Type Theory \land Lazyness \implies Super Language $
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Agenda</h1>
    <ul>
        <li>A brief of History</li>
        <li>Functional Programming</li>
        <li><strong>Data structures: Datatypes, Types, Typeclasses and more</strong></li>
        <li>Type Level Programming</li>
        <li>Theorems for free</li>
    </ul>

</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <h2>Sum Types $ A + B $ Either, IO, etc</h2>
    <pre>
        <code class="scala htl">
    sealed abstract class Either[+A, +B]
    final case class Left[+A, +B](a: A) extends Either[A, B]
    final case class Right[+A, +B](b: B) extends Either[A, B]
        </code>
    </pre>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <h2>Sum Types $ A + B $ Either, IO, etc</h2>
    <pre>
        <code class="scala htl">
    sealed abstract class Either[+A, +B]
    final case class Left[+A, +B](a: A) extends Either[A, B]
    final case class Right[+A, +B](b: B) extends Either[A, B]
        </code>
    </pre>
    <h2>In Haskell :D</h2>
    <pre>
        <code class="haskell htl">
    data Either a b = Left a | Right b
        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <h2>Product Types $ A * B $ Any Class</h2>
    <pre>
        <code class="scala htl">
    case class User(address: Address, name: String, surname: String)
    case class Billing(items: Seq[Item], user: User, ...)
        </code>
    </pre>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <h2>Product Types $ A * B $ Any Class</h2>
    <pre>
        <code class="scala htl">
    case class User(address: Address, name: String, surname: String)
    case class Billing(items: Seq[Item], user: User, ...)
        </code>
    </pre>
    <h2>Haskell ...</h2>
    <pre>
        <code class="haskell htl">
    data User = User Address String String
    -- Or with named records
    data User = User { address: Address, name: String, surname: String }
        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <h2>Exponential Types $ B^A \cong Functions $</h2>
    <pre>
        <code class="scala htl">
    def f: A => B = ...
    def f(a: A): B = ...
        </code>
    </pre>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <h2>Exponential Types $ B^A \cong Functions $</h2>
    <pre>
        <code class="scala htl">
    def f: A => B = ...
    def f(a: A): B = ...
        </code>
    </pre>
    <h2>Haskell ...</h2>
    <pre>
        <code class="haskell htl">
    f :: A -> B
        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <ul>
        <li>All we need are 3 Types: Sum, Product and Exponentials</li>
    </ul>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <ul>
        <li>All we need are 3 Types: Sum, Product and Exponentials</li>
        <li>Because of this are also known as ADT - <strong>Algebraic Data Types</strong></li>
    </ul>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <ul>
        <li>All we need are 3 Types: Sum, Product and Exponentials</li>
        <li>Because of this are also known as ADT - <strong>Algebraic Data Types</strong></li>
    </ul>
    <h2>High School</h2>
    <ul>
        <li>$ (A*B)^C = A^C * B^C $</li>
    </ul>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <ul>
        <li>All we need are 3 Types: Sum, Product and Exponentials</li>
        <li>Because of this are also known as ADT - <strong>Algebraic Data Types</strong></li>
    </ul>
    <h2>Curry-Howard Isomorphism/Correspondence</h2>
    <ul>
        <li>$ (A*B)^C = A^C * B^C $</li>
    </ul>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <ul>
        <li>All we need are 3 Types: Sum, Product and Exponentials</li>
        <li>Because of this are also known as ADT - <strong>Algebraic Data Types</strong></li>
    </ul>
    <h2>Curry-Howard Isomorphism/Correspondence</h2>
    <ul>
        <li>$ (A*B)^C = A^C * B^C \mapsto c \to (a,b) \cong (c \to a, c \to b) $</li>
    </ul>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Data Structures</h1>
    <ul>
        <li>All we need are 3 Types: Sum, Product and Exponentials</li>
        <li>Because of this are also known as ADT - <strong>Algebraic Data Types</strong></li>
    </ul>
    <h2>Scala Code</h2>
    <pre>
        <code class="scala htl">
    case class Product[+A, +B](a: A, b: B)

    def f[+A,+B,+C](c: C): Product[A,B]

    def ca[+A,+C](c: C): A
    def cb[+B,+C](c: C): B

    def caCbToProd[+A,+B,+C](c: C) = Product(ca(c), cb(c))
        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Other Isomorphisms</h1>
    <ul>
        <li>$ C^{A*B} = C^A * C^B $</li>
        <li>$ B^{A^C} = B^{A*C} $</li>
    </ul>
    <h2>And what about Typeclasses?</h2>
</div>

<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Data Structures
## Typeclasses
> A set of types which have certain operations defined for them. As known as **Algebras** in FP.
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Typeclasses in Scala</h1>
    <pre>
        <code class="scala htl">
    trait Functor[F[_]] {
      def map[A, B](fa: F[A])(f: A => B): F[B]
    }

    // Example implementation for Option
    implicit val functorForOption: Functor[Option] = new Functor[Option] {
      def map[A, B](fa: Option[A])(f: A => B): Option[B] = fa match {
        case None    => None
        case Some(a) => Some(f(a))
      }
    }
        </code>
    </pre>
</div>
<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>and in Haskell</h1>
    <pre>
        <code class="haskell htl">
    class Functor f where
      fmap :: (a -> b) -> f a -> f b

    instance Functor Maybe where
      fmap f (Just x) = Just (f x)
      fmap _ Nothing  = Nothing
        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Agenda</h1>
    <ul>
        <li>A brief of History</li>
        <li>Functional Programming</li>
        <li>Data structures: Datatypes, Types, Typeclasses and more</li>
        <li><strong>Type Level Programming</strong></li>
        <li>Theorems for free</li>
    </ul>

</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <ul>
        <li>Express program behavoiur with <strong>Types</strong></li>
   </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <ul>
        <li>Express program behavoiur with <strong>Types</strong></li>
        <li>Benefits:
            <ul>
                <li>Reason about your program $ \implies Math$</li>
           </ul>
        </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <ul>
        <li>Express program behavoiur with <strong>Types</strong></li>
        <li>Benefits:
            <ul>
                <li>Reason about your program $ \implies Math$</li>
                <li>Move from Runtime to Compile Time</li>
           </ul>
        </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <ul>
        <li>Express program behavoiur with <strong>Types</strong></li>
        <li>Benefits:
            <ul>
                <li>Reason about your program $ \implies Math$</li>
                <li>Move from Runtime to Compile Time</li>
                <li>Minimize Runtime Errors</li>
           </ul>
        </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <ul>
        <li>Express program behavoiur with <strong>Types</strong></li>
        <li>Benefits:
            <ul>
                <li>Reason about your program $ \implies Math$</li>
                <li>Move from Runtime to Compile Time</li>
                <li>Minimize Runtime Errors</li>
                <li><b><i>Propositions as Types, Program as Proofs</i></b></li>
            </ul>
        </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <ul>
        <li>Express program behavoiur with <strong>Types</strong></li>
        <li>Benefits:
            <ul>
                <li>Reason about your program $ \implies Math$</li>
                <li>Move from Runtime to Compile Time</li>
                <li>Minimize Runtime Errors</li>
                <li><b><i>Propositions as Types, Program as Proofs</i></b></li>
                <li><strong>Theorems for free</strong> (Category Theory and Type Theory for example)
               </li>
            </ul>
        </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <ul>
        <li>Express program behavoiur with <strong>Types</strong></li>
        <li>Benefits:
            <ul>
                <li>Reason about your program $ \implies Math$</li>
                <li>Move from Runtime to Compile Time</li>
                <li>Minimize Runtime Errors</li>
                <li><b><i>Propositions as Types, Program as Proofs</i></b></li>
                <li><strong>Theorems for free</strong> (Category Theory and Type Theory for example)
                    <ul>
                        <li><b>LESS Testing</b></li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <ul>
        <li>Express program behavoiur with <strong>Types</strong></li>
        <li>Benefits:
            <ul>
                <li>Reason about your program $ \implies Math$</li>
                <li>Move from Runtime to Compile Time</li>
                <li>Minimize Runtime Errors</li>
                <li><b><i>Propositions as Types, Program as Proofs</i></b></li>
                <li><strong>Theorems for free</strong> (Category Theory and Type Theory for example)
                    <ul>
                        <li><b>LESS Testing</b></li>
                        <li><strong>YES</strong> the compiler Tests things for you</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <h2>Going from this ....</h2>
    <pre>
        <code class="scala htl">

    def getUserFromDatabase(userId: String): User = {
       if(userId != null && !userId.isEmpty{
         userDb.findUser(userId)
       }else{
         null  //?????
       }
    }
       </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <h2>Avoiding NullPointer with Expressiveness: $Maybe | Option$</h2>
    <pre>
        <code class="scala htl">

  def getUserFromDatabase(userId: Option[String]): Option[User] =
    userId.map(userDb.find(_)) 

    /// Or more verbose

  def getUserFromDatabase(userId: Option[String]): Option[User] = {
    userId match {
      case Some(id) => Option(userDb.find(id))
      case None     => None
    }
  }

        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <h2>In Haskell ....</h2>
    <pre>
        <code class="haskell htl">

  userFromDatabase :: Maybe String -> Maybe User
  userFromDatabase id = fmap findUser id

  -- Even less verbose with point free style

  userFromDatabase :: Maybe String -> Maybe User
  userFromDatabase = fmap findUser

       </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <h2>What about error handling?</h2>
    <pre>
        <code class="scala htl">

    def getUserFromDatabase(userId: String): User = {
       if(userId != null && !userId.isEmpty{
         try{
           userDb.findUser(userId)
         }catch {
           case e: Throwable => ????
         }
       }else{
         throw new NotUserFound("User not found")
       }
    }
        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <h2>Again Expressiveness: Sum Type to Rescue $Either$</h2>
    <pre>
        <code class="scala htl">

  sealed abstract class Either[+A, +B]
  final case class Left[+A, +B](a: A) extends Either[A, B]
  final case class Right[+A, +B](b: B) extends Either[A, B] 

  def getUserFromDatabase(userId: Option[String]): Either[AppError, User] =
    userId.toRight(UsedIdNotProvided).map(userDb.find(_)) 

        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Type Level Programming</h1>
    <h2>In Haskell ....</h2>
    <pre>
        <code class="haskell htl">

  validUserId :: Maybe String -> Either AppError String
  validUserId = maybeToEither UserIdNotProvided 

  userFromDatabase :: Maybe String -> Either AppError User
  userFromDatabase = (fmap findUser) . validUserId

        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">

    <h1>Agenda</h1>
    <ul>
        <li>A brief of History</li>
        <li>Functional Programming</li>
        <li>Data structures: Datatypes, Types, Typeclasses and more</li>
        <li>Type Level Programming</li>
        <li><strong>Theorems for free</strong></li>
    </ul>

</div>

<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Theorems for free

- What if we can have well defined Types which obey some laws and those laws obey some well defined and prooven theory?
</div>

<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Theorems for free

- What if we can have well defined Types which obey some laws and those laws obey some well defined and prooven theory?

- Would our programs be more well defined, precise and prooven if it uses those Types?
</div>

<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
# Theorems for free

- What if we can have well defined Types which obey some laws and those laws obey some well defined and prooven theory?

- Would our programs be more well defined, precise and prooven if it uses those Types?</h3>

# **Of course!!!**

## And Category Theory is one of them
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Theorems for free</h1>
    <h2>Typeclasses: Functor</h2>

    <pre>
        <code class="haskell htl">
  class Functor f where
    fmap :: (a -> b) -> f a -> f b

  instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap _ Nothing  = Nothing
        </code>
    </pre>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Theorems for free</h1>
    <h2>Typeclasses: Functor</h2>
    <ul>
        <li>A functor $F: C \to D$ between categories $C$ and $D$ is a mapping of objects to objects and arrows to arrows, in such a way that:
            <ul>
                <li>$(a) F(f: A \to B) = F(f): F(A) \to F(B)$</li>
                <li>$(b) F(1_A) = 1_F(A)$</li>
                <li>$(c) F(g \circ f) = F(g) \circ F(f)$</li>
            </ul>
        </li>
    </ul>
    <center><strong>????</strong></center>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Theorems for free</h1>
    <h2>Typeclasses: Functor</h2> 
    <ul>
        <li>In the context of a Programming language a Functor <b>is a Type that can be mapped over preserving the structure</b></li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Theorems for free</h1>
    <h2>Typeclasses: Functor</h2> 
    <ul>
        <li>In the context of a Programming language a Functor <b>is a Type that can be mapped over preserving the structure</b></li>
        <li>An obey some laws..
       </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Theorems for free</h1>
    <h2>Typeclasses: Functor</h2> 
    <ul>
        <li>In the context of a Programming language a Functor <b>is a Type that can be mapped over preserving the structure</b></li>
        <li>An obey some laws..
            <ul>
                <li>Functors must preserve identity morphisms</li>
                <pre><code class="haskell htl">fmap id = id</code></pre>
           </ul>
        </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Theorems for free</h1>
    <h2>Typeclasses: Functor</h2> 
    <ul>
        <li>In the context of a Programming language a Functor <b>is a Type that can be mapped over preserving the structure</b></li>
        <li>An obey some laws..
            <ul>
                <li>Functors must preserve identity morphisms</li>
                <pre><code class="haskell htl">fmap id = id</code></pre>
                <li>Functors preserve composition of morphisms</li>
                <pre><code class="haskell htl">fmap (f . g)  ==  fmap f . fmap g</code></pre>
            </ul>
        </li>
    </ul>
</div>

<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Theorems for free</h1>
    <h2>Typeclasses: Functor</h2> 
    <ul>
        <li>Going back to $Maybe|Option$ Type which implements Functor Typeclass</li>
    </ul>
</div>


<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Theorems for free</h1>
    <h2>Typeclasses: Functor</h2> 
    <ul>
        <li>Going back to $Maybe|Option$ Type which implements Functor Typeclass</li>
        <li>It preservers structure obeying laws</li>
        <pre><code class="haskell htl">
    def getUserFromDatabase(userId: Option[String]): Option[User] =
    userId.map(userDb.find(_)) 
      </code></pre>
        <pre><code class="haskell htl">
   fmap ((+1) . (*2)) (Just 1) == fmap (+1) (fmap (*2) (Just 1))
        </code></pre>
        <p>No need to test Functor over compision. Laws for free!!</p>
    </ul>
</div>


<div class="step slide" data-rel-x="1800" data-rel-y="0">
    <h1>Theorems for free</h1>
    <h2>Typeclasses: Much more than Functors</h2> 
    <ul>
        <li><b>Monoid</b>: Type for combining values. Does it sound string concatenation to you?</li>
        <li><b>Applicative</b>: Functor with Application</li>
        <li><b>Monads</b>: Composable computation descriptions (In language terms not Cat Theory)</li>
        <li>And so much more:
            <ul>
                <li>Semigroup, Group, Foldable, Transversable, Bifunctor, Arrow, Comonad, etc.</li> 
    </ul>
</div>


<div class="step slide markdown" data-rel-x="1800" data-rel-y="0">
<center># Questions ??????</center>
</div>

<script type="text/javascript">
 var enableBwCss = function(){
     disableDevopsCss();
     disableEffectsCss();
 };
 var enableDevopsCss = function(){
     document.body.classList.add("devopsy");
     disableEffectsCss();
 };
 var disableDevopsCss = function(){
     document.body.classList.remove("devopsy");
 };
 var enableEffectsCss = function(){
     document.body.classList.add("effects");
     disableDevopsCss();
 };
 var disableEffectsCss = function(){
     document.body.classList.remove("effects");
 };
</script>


<div id="impress-toolbar"></div>
<div id="impress-help"></div>


<!-- Extra modules
     Load highlight.js, mermaid.js and markdown.js from extras.
     See also src/plugins/extras/extras.js -->
<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script type="text/javascript" src="/js/mermaid.min.js"></script>
<script type="text/javascript" src="/js/markdown.js"></script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
     tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
 });
</script>
<script type="text/javascript" src="/js/MathJax.js?config=TeX-AMS_CHTML"></script>
<script type="text/javascript" src="/js/impress.js"></script>
<!--
     To make all described above really work, you need to include impress.js in the page.
     You also need to call a `impress().init()` function to initialize impress.js presentation.
     And you should do it in the end of your document.
-->
<script>impress().init();</script>
</body>
</html>
