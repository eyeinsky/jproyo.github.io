<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>From Lambda Calculus to Scala FP | by Juan Pablo Royo @juanpabloroyo</title>
    <meta name="description" content="From Lambda Calculus to Scala FP Slides" />
    <meta name="author" content="Juan Pablo Royo Sales" />
    <link rel="stylesheet" href="/css/hybrid.css">

    <!--
        Styles specific for this example presentation.
    -->
    <link href="/css/markdown-slides.css" rel="stylesheet" />
    <link href="/css/devopsy.css" rel="stylesheet" />
    <link href="/css/effects.css" rel="stylesheet" />
</head>

<body class="impress-not-supported">
<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress" data-transition-duration="700">

<div class="step slide" data-rel-x="1800" data-rel-y="0">

<h1>From Lambda Calculus to Scala FP</h1>
<div style="display: block;">
  <img src="/assets/images/super-lambda.jpg" style="float: left"/>
  <img src="/assets/images/scala.png" style="float: right; width: 21%"/>
</div>
</div>


<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="50">

<h1>Agenda</h1>
<ul>
  <li>A brief of History</li>
  <li>Functional Programming</li>
  <li>Data structures: Datatypes, Types, Typeclasses and more</li>
  <li>for comprehension? Is there a conspiracy?</li>
  <li>From imperative to FP λ</li>
  <li>Extras: Category Theory and other FP techniques</li>
</ul>

</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100">

<h1>Agenda</h1>
<ul>
  <li><strong>A brief of History</strong></li>
  <li>Functional Programming</li>
  <li>Data structures: Datatypes, Types, Typeclasses and more</li>
  <li>for comprehension? Is there a conspiracy?</li>
  <li>From imperative to FP λ</li>
  <li>Extras: Category Theory and other FP techniques</li>
</ul>

</div>

<div class="step slide" data-rel-x="1600" data-rel-y="100" data-rotate="50">

<h1>Computability Theory</h1>
<blockquote>
<p>
  Branch of mathematics <b>(logic)</b> - Study of <b>Computable Functions</b> / Solvable Problems. (Before 1930 - No machines)
  $ f(x) = y $
</p>
</blockquote>
</div>

<div class="step slide markdown" data-rel-x="1700" data-rel-y="100">

# Computability Theory

> ![Hilbert](/assets/images/Hilbert.jpg) Belived all problems were solvable, but around 1930  Gödel, Turing, and Church showed that this is not the case.

</div>

<div class="step slide markdown" data-rel-x="1700" data-rel-y="200" data-rotate="-50">
# Computability Theory

![Alonzo Church](/assets/images/Alonzo_Church.jpg) Discovered/Introduced in 1930 **Lambda Calculus** as a formal system for expressing computations based on function abstractions and function applications.

</div>
<div class="step slide markdown" data-rel-x="1700" data-rel-y="200" data-rotate="50">
# Lambda Calculus (a.k.a. Untyped Lambda Calculus)

* Lambda Terms - Only 3 elements

$ Set \Lambda of all \lambda-terms$
$ (Variable) | u \in V \implies u \in \Lambda$
$ (Application) | M \land N \in \Lambda \implies (MN) \in \Lambda$
$ (Abstraction) | u \in V \land M \in \Lambda \implies \(\lambda u.M\) \in \Lambda$
</div>
<div class="step slide markdown" data-rel-x="1700" data-rel-y="200">
# $\(\lambda u.M\)$ Examples

* Booleans = True | False
  * $ \lambda xy.x \cong TRUE$
  * $ \lambda xy.y \cong FALSE$
* Natural Numbers
  * $ 0 \cong \lambda fx.x$
  * $ 1 \cong \lambda fx.fx$
  * $ 2 \cong \lambda fx.f\(fx\)$
  * $ 3 \cong \lambda fx.f\(f\(fx\)\)$
  * and so on.....
</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="50">

<h1>Agenda</h1>
<ul>
  <li>A brief of History</li>
  <li><strong>Functional Programming</strong></li>
  <li>Data structures: Datatypes, Types, Typeclasses and more</li>
  <li>for comprehension? Is there a conspiracy?</li>
  <li>From imperative to FP λ</li>
  <li>Extras: Category Theory and other FP techniques</li>
</ul>

</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="-50">

<h1>Functional Programming</h1>
<ul>
  <li>Paradigm that relies on functions modeled on <b>mathematical functions $\cong \lambda Calculus?$</b></li>
  <li>Functions are <b>First-class</b></li>
  <li>Pure functions
    <ul>
      <li>Referential transparency: <b>same function</b>, given the <b>same values</b> to be evaluated, will always return the <b>same result</b> $\cong Math$</li>
    </ul>
  </li>
  <li>Why is RF so important?
    <ul>
      <li>Deterministic, Composable, Testable, No Side Effects Programs</li>
    </ul>
  </li>
</ul>

</div>

<div class="step slide markdown" data-rel-x="1700" data-rel-y="200" data-rotate="50">
# Functional Programming
> Well defined FP languages like Haskell, Scala, Agda, etc also are **Lazy** and Strict Typed Language.
> Combination of all these properties build well formal defined language tooling

$ \lambda Calculus \land Type Theory \land Lazyness \implies Super Language $
</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="-50">

<h1>Agenda</h1>
<ul>
  <li>A brief of History</li>
  <li>Functional Programming</li>
  <li><strong>Data structures: Datatypes, Types, Typeclasses and more</strong></li>
  <li>for comprehension? Is there a conspiracy?</li>
  <li>From imperative to FP λ</li>
  <li>Extras: Category Theory and other FP techniques</li>
</ul>

</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="50">
<h1>Data Structures</h1>
<h2>Sum Types $ A + B $ Either, IO, etc</h2>
<pre>
  <code class="scala htl">
    sealed abstract class Either[+A, +B]
    final case class Left[+A, +B](a: A) extends Either[A, B]
    final case class Right[+A, +B](b: B) extends Either[A, B]
  </code>
</pre>
<h2>In Haskell :D</h2>
<pre>
  <code class="haskell htl">
    data Either a b = Left a | Right b
  </code>
  </pre>
</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="-50">
<h1>Data Structures</h1>
<h2>Product Types $ A * B $ Any Class</h2>
<pre>
  <code class="scala htl">
    case class User(address: Address, name: String, surname: String)
    case class Billing(items: Seq[Item], user: User, ...)
  </code>
</pre>
<h2>Haskell ...</h2>
<pre>
  <code class="haskell htl">
    data User = User Address String String
    -- Or with named records
    data User = User { address: Address, name: String, surname: String }
  </code>
  </pre>
</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="-50">
<h1>Data Structures</h1>
<h2>Exponential Types $ B^A \cong Functions $</h2>
<pre>
  <code class="scala htl">
    def f: A => B = ...
    def f(a: A): B = ...
  </code>
</pre>
<h2>Haskell ...</h2>
<pre>
  <code class="haskell htl">
    f :: A -> B
  </code>
  </pre>
</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="50">
<h1>Data Structures</h1>
<ul>
  <li>All we need are 3 Types: Sum, Product and Exponentials</li>
  <li>Because of this are also known as ADT - **Algebraic Data Types**</li>
</ul>
<h2>High School</h2>
<ul>
  <li>$ (A*B)^C = A^C * B^C $</li>
</ul>
<pre>
  <code class="scala htl">
    case class Product[+A, +B](a: A, b: B)

    def f[+A,+B,+C](c: C): Product[A,B]

    def ca[+A,+C](c: C): A
    def cb[+B,+C](c: C): B

    def caCbToProd[+A,+B,+C](c: C) = Product(ca(c), cb(b))
  </code>
</pre>
</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="50">
<h1>Other Isomorphisms</h1>
<ul>
  <li>$ C^{A*B} = C^A * C^B $</li>
  <li>$ B^{A^C} = B^{A*C} $</li>
</ul>
<h2>And what about Typeclasses?</h2>
</div>

<div class="step slide markdown" data-rel-x="1700" data-rel-y="100" data-rotate="-50">
# Data Structures
## Typeclasses
> A set of types which have certain operations defined for them. We also called Algebras sometime in FP.
</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="50">
<h1>Typeclasses in Scala</h1>
<pre>
  <code class="scala htl">
    trait Functor[F[_]] {
      def map[A, B](fa: F[A])(f: A => B): F[B]
    }

    // Example implementation for Option
    implicit val functorForOption: Functor[Option] = new Functor[Option] {
      def map[A, B](fa: Option[A])(f: A => B): Option[B] = fa match {
        case None    => None
        case Some(a) => Some(f(a))
      }
    }
  </code>
</pre>
</div>
<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="50">
<h1>and in Haskell</h1>
<pre>
  <code class="haskell htl">
    class Functor f where
      fmap :: (a -> b) -> f a -> f b

    instance Functor Maybe where
      fmap f (Just x) = Just (f x)
      fmap _ Nothing  = Nothing
  </code>
  </pre>
</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="-50">

<h1>Agenda</h1>
<ul>
  <li>A brief of History</li>
  <li>Functional Programming</li>
  <li>Data structures: Datatypes, Types, Typeclasses and more</li>
  <li><strong>for comprehension? Is there a conspiracy?</strong></li>
  <li>From imperative to FP λ</li>
  <li>Extras: Category Theory and other FP techniques</li>
</ul>

</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="50">
<h1>for comprehension? Is there a conspiracy?</h1>
<ul><li>It is a <b>syntactic sugar</b> for the combination of flatMap, map and withFilter. Nothing else, nothing more</li></ul>
<pre>
  <code class="scala htl">
    for {
      i <- a
      j <- b
      k <- c
    } yield (i + j + k)

    a.flatMap { i =>
      b.flatMap { j =>
        c.map {
          k => i + j + k
        }
      }
    }
</code>
</pre>
</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="-50">
<h1>With Filters</h1>
<pre>
  <code class="scala htl">
    for {
      i <- a
      j <- b
      if i > j
      k <- c
    } yield (i + j + k)

    a.flatMap { i =>
      b.withFilter { j => i > j }.flatMap { j =>
        c.map {
          k => i + j + k
        }
      }
    }
  </code>
</pre>
</div>
<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="50">
<h1>With Assignments</h1>
<pre>
  <code class="scala htl">
    for {
      i <- a
      j <- b
      ij = i + j
      k <- c
    } yield (ij + k)

    a.flatMap { i =>
      b.map { j => (j, i+j) }.flatMap { (j, ij) =>
        c.map {
          k => ij + k
        }
      }
    }
  </code>
</pre>
</div>
<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="-50">

<h1>Agenda</h1>
<ul>
  <li>A brief of History</li>
  <li>Functional Programming</li>
  <li>Data structures: Datatypes, Types, Typeclasses and more</li>
  <li>for comprehension? Is there a conspiracy</li>
  <li><strong>From imperative to FP λ?</strong></li>
  <li>Extras: Category Theory and other FP techniques</li>
</ul>

</div>

<div class="step slide markdown" data-rel-x="1700" data-rel-y="100" data-rotate="50">

# From imperative to FP $ \lambda $

## Coding Time!! ![Coding time](https://media.giphy.com/media/zOvBKUUEERdNm/giphy.gif)

</div>

<div class="step slide" data-rel-x="1700" data-rel-y="100" data-rotate="-50">

<h1>Agenda</h1>
<ul>
  <li>A brief of History</li>
  <li>Functional Programming</li>
  <li>Data structures: Datatypes, Types, Typeclasses and more</li>
  <li>for comprehension? Is there a conspiracy</li>
  <li>From imperative to FP λ?</li>
  <li><strong>Extras: Category Theory and other FP techniques</strong></li>
</ul>

</div>
<div class="step slide markdown" data-rel-x="1700" data-rel-y="100" data-rotate="50">
# Extras: Category Theory and other FP techniques
* Functor
* Monoid
* Applicative
* Monad
* Reader, Writer, State
* Monad Transformers
* Free Monads
</div>

<script type="text/javascript">
var enableBwCss = function(){
    disableDevopsCss();
    disableEffectsCss();
};
var enableDevopsCss = function(){
    document.body.classList.add("devopsy");
    disableEffectsCss();
};
var disableDevopsCss = function(){
    document.body.classList.remove("devopsy");
};
var enableEffectsCss = function(){
    document.body.classList.add("effects");
    disableDevopsCss();
};
var disableEffectsCss = function(){
    document.body.classList.remove("effects");
};
</script>


<div id="impress-toolbar"></div>
<div id="impress-help"></div>


<!-- Extra modules
     Load highlight.js, mermaid.js and markdown.js from extras.
     See also src/plugins/extras/extras.js -->
<script type="text/javascript" src="../js/highlight.pack.js"></script>
<script type="text/javascript" src="../js/mermaid.min.js"></script>
<script type="text/javascript" src="../js/markdown.js"></script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
     tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
 });
</script>
<script type="text/javascript" src="../js/MathJax.js?config=TeX-AMS_CHTML"></script>
<script type="text/javascript" src="../js/impress.js"></script>
<!--
    To make all described above really work, you need to include impress.js in the page.
    You also need to call a `impress().init()` function to initialize impress.js presentation.
    And you should do it in the end of your document.
-->
<script>impress().init();</script>
</body>
</html>
